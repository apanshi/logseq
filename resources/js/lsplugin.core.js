/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["LSPlugin"] = factory();
	else
		root["LSPlugin"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/***/ (function(module) {

eval("/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n\n  var regExpTest = unapply(RegExp.prototype.test);\n\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  /* Add properties to a lookup table */\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n    while (l--) {\n      var element = array[l];\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  /* Shallow clone an object */\n  function clone(object) {\n    var newObject = create(null);\n\n    var property = void 0;\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\n  var text = freeze(['#text']);\n\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '2.3.1';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n\n\n    var ElementPrototype = Element.prototype;\n\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        createDocumentFragment = _document.createDocumentFragment,\n        getElementsByTagName = _document.getElementsByTagName;\n    var importNode = originalDocument.importNode;\n\n\n    var documentMode = {};\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n    /* Allowed attribute names */\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    var FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    var FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    var ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    var ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    var SAFE_FOR_TEMPLATES = false;\n\n    /* Decide if document with <html>... should be returned */\n    var WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    var SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    var FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    var RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    var RETURN_DOM_FRAGMENT = false;\n\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n    var RETURN_DOM_IMPORT = true;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    var RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks? */\n    var SANITIZE_DOM = true;\n\n    /* Keep element content when removing element? */\n    var KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    var IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    var USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    var FORBID_CONTENTS = null;\n    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n\n    /* Keep a reference to config to pass to hooks */\n    var CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, { element: node });\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n\n      // We void attribute values for unremovable \"is\"\" attributes\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n        } catch (_) {}\n      }\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n        } catch (_) {\n          // Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      var body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check if tagname contains Unicode */\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      var tagName = stringToLowerCase(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Mitigate a problem with templates inside select */\n      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            var childCount = childNodes.length;\n\n            for (var i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n        return false;\n      }\n\n      return true;\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n\n        value = stringTrim(attr.value);\n        lcName = stringToLowerCase(name);\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n        _removeAttribute(name, currentNode);\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        /* Is `value` valid for this attribute? */\n        var lcTag = currentNode.nodeName.toLowerCase();\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n      var shadowIterator = _createIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      /* Check we can run. Otherwise fall back or ignore */\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ; else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = stringToLowerCase(tag);\n      var lcName = stringToLowerCase(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/dompurify/dist/purify.js?");

/***/ }),

/***/ "./node_modules/dot-case/dist.es2015/index.js":
/*!****************************************************!*\
  !*** ./node_modules/dot-case/dist.es2015/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dotCase\": () => (/* binding */ dotCase)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var no_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! no-case */ \"./node_modules/no-case/dist.es2015/index.js\");\n\n\nfunction dotCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return (0,no_case__WEBPACK_IMPORTED_MODULE_0__.noCase)(input, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({ delimiter: \".\" }, options));\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://LSPlugin/./node_modules/dot-case/dist.es2015/index.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/lower-case/dist.es2015/index.js":
/*!******************************************************!*\
  !*** ./node_modules/lower-case/dist.es2015/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"localeLowerCase\": () => (/* binding */ localeLowerCase),\n/* harmony export */   \"lowerCase\": () => (/* binding */ lowerCase)\n/* harmony export */ });\n/**\n * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n */\nvar SUPPORTED_LOCALE = {\n    tr: {\n        regexp: /\\u0130|\\u0049|\\u0049\\u0307/g,\n        map: {\n            İ: \"\\u0069\",\n            I: \"\\u0131\",\n            İ: \"\\u0069\",\n        },\n    },\n    az: {\n        regexp: /\\u0130/g,\n        map: {\n            İ: \"\\u0069\",\n            I: \"\\u0131\",\n            İ: \"\\u0069\",\n        },\n    },\n    lt: {\n        regexp: /\\u0049|\\u004A|\\u012E|\\u00CC|\\u00CD|\\u0128/g,\n        map: {\n            I: \"\\u0069\\u0307\",\n            J: \"\\u006A\\u0307\",\n            Į: \"\\u012F\\u0307\",\n            Ì: \"\\u0069\\u0307\\u0300\",\n            Í: \"\\u0069\\u0307\\u0301\",\n            Ĩ: \"\\u0069\\u0307\\u0303\",\n        },\n    },\n};\n/**\n * Localized lower case.\n */\nfunction localeLowerCase(str, locale) {\n    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];\n    if (lang)\n        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));\n    return lowerCase(str);\n}\n/**\n * Lower case as a function.\n */\nfunction lowerCase(str) {\n    return str.toLowerCase();\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://LSPlugin/./node_modules/lower-case/dist.es2015/index.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/no-case/dist.es2015/index.js":
/*!***************************************************!*\
  !*** ./node_modules/no-case/dist.es2015/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"noCase\": () => (/* binding */ noCase)\n/* harmony export */ });\n/* harmony import */ var lower_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lower-case */ \"./node_modules/lower-case/dist.es2015/index.js\");\n\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nvar DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];\n// Remove all non-word characters.\nvar DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;\n/**\n * Normalize the string into something other libraries can manipulate easier.\n */\nfunction noCase(input, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lower_case__WEBPACK_IMPORTED_MODULE_0__.lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? \" \" : _d;\n    var result = replace(replace(input, splitRegexp, \"$1\\0$2\"), stripRegexp, \"\\0\");\n    var start = 0;\n    var end = result.length;\n    // Trim the delimiter from around the output string.\n    while (result.charAt(start) === \"\\0\")\n        start++;\n    while (result.charAt(end - 1) === \"\\0\")\n        end--;\n    // Transform each token independently.\n    return result.slice(start, end).split(\"\\0\").map(transform).join(delimiter);\n}\n/**\n * Replace `re` in the input string with the replacement value.\n */\nfunction replace(input, re, value) {\n    if (re instanceof RegExp)\n        return input.replace(re, value);\n    return re.reduce(function (input, re) { return input.replace(re, value); }, input);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://LSPlugin/./node_modules/no-case/dist.es2015/index.js?");

/***/ }),

/***/ "./node_modules/path/path.js":
/*!***********************************!*\
  !*** ./node_modules/path/path.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = process.env['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/path/path.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/snake-case/dist.es2015/index.js":
/*!******************************************************!*\
  !*** ./node_modules/snake-case/dist.es2015/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"snakeCase\": () => (/* binding */ snakeCase)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var dot_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dot-case */ \"./node_modules/dot-case/dist.es2015/index.js\");\n\n\nfunction snakeCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return (0,dot_case__WEBPACK_IMPORTED_MODULE_0__.dotCase)(input, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({ delimiter: \"_\" }, options));\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://LSPlugin/./node_modules/snake-case/dist.es2015/index.js?");

/***/ }),

/***/ "./src/LSPlugin.caller.ts":
/*!********************************!*\
  !*** ./src/LSPlugin.caller.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FLAG_AWAIT\": () => (/* binding */ FLAG_AWAIT),\n/* harmony export */   \"LSPMSG\": () => (/* binding */ LSPMSG),\n/* harmony export */   \"LSPMSG_ERROR_TAG\": () => (/* binding */ LSPMSG_ERROR_TAG),\n/* harmony export */   \"LSPMSG_SETTINGS\": () => (/* binding */ LSPMSG_SETTINGS),\n/* harmony export */   \"LSPMSG_BEFORE_UNLOAD\": () => (/* binding */ LSPMSG_BEFORE_UNLOAD),\n/* harmony export */   \"LSPMSG_SYNC\": () => (/* binding */ LSPMSG_SYNC),\n/* harmony export */   \"LSPMSG_READY\": () => (/* binding */ LSPMSG_READY),\n/* harmony export */   \"LSPMSGFn\": () => (/* binding */ LSPMSGFn),\n/* harmony export */   \"AWAIT_LSPMSGFn\": () => (/* binding */ AWAIT_LSPMSGFn),\n/* harmony export */   \"LSPluginCaller\": () => (/* binding */ LSPluginCaller)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _postmate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./postmate */ \"./src/postmate/index.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n/* harmony import */ var _LSPlugin_shadow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LSPlugin.shadow */ \"./src/LSPlugin.shadow.ts\");\n\n\n\n\n\nconst debug = debug__WEBPACK_IMPORTED_MODULE_0___default()('LSPlugin:caller');\nconst FLAG_AWAIT = '#await#response#';\nconst LSPMSG = '#lspmsg#';\nconst LSPMSG_ERROR_TAG = '#lspmsg#error#';\nconst LSPMSG_SETTINGS = '#lspmsg#settings#';\nconst LSPMSG_BEFORE_UNLOAD = '#lspmsg#beforeunload#';\nconst LSPMSG_SYNC = '#lspmsg#reply#';\nconst LSPMSG_READY = '#lspmsg#ready#';\nconst LSPMSGFn = (id) => `${LSPMSG}${id}`;\nconst AWAIT_LSPMSGFn = (id) => `${FLAG_AWAIT}${id}`;\n/**\n * Call between core and user\n */\nclass LSPluginCaller extends (eventemitter3__WEBPACK_IMPORTED_MODULE_2___default()) {\n    _pluginLocal;\n    _connected = false;\n    _parent;\n    _child;\n    _shadow;\n    _status;\n    _userModel = {};\n    _call;\n    _callUserModel;\n    _debugTag = '';\n    constructor(_pluginLocal) {\n        super();\n        this._pluginLocal = _pluginLocal;\n        if (_pluginLocal) {\n            this._debugTag = _pluginLocal.debugTag;\n        }\n    }\n    async connectToChild() {\n        if (this._connected)\n            return;\n        const { shadow } = this._pluginLocal;\n        if (shadow) {\n            await this._setupShadowSandbox();\n        }\n        else {\n            await this._setupIframeSandbox();\n        }\n    }\n    // run in sandbox\n    async connectToParent(userModel = {}) {\n        if (this._connected)\n            return;\n        const caller = this;\n        const isShadowMode = this._pluginLocal != null;\n        let syncGCTimer = 0;\n        let syncTag = 0;\n        const syncActors = new Map();\n        const readyDeferred = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.deferred)(1000 * 5);\n        const model = this._extendUserModel({\n            [LSPMSG_READY]: async (baseInfo) => {\n                // dynamically setup common msg handler\n                model[LSPMSGFn(baseInfo?.pid)] = ({ type, payload }) => {\n                    debug(`[call from host (_call)] ${this._debugTag}`, type, payload);\n                    // host._call without async\n                    caller.emit(type, payload);\n                };\n                await readyDeferred.resolve();\n            },\n            [LSPMSG_BEFORE_UNLOAD]: async (e) => {\n                const actor = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.deferred)(10 * 1000);\n                caller.emit('beforeunload', Object.assign({ actor }, e));\n                await actor.promise;\n            },\n            [LSPMSG_SETTINGS]: async ({ type, payload }) => {\n                caller.emit('settings:changed', payload);\n            },\n            [LSPMSG]: async ({ ns, type, payload }) => {\n                debug(`[call from host (async)] ${this._debugTag}`, ns, type, payload);\n                if (ns && ns.startsWith('hook')) {\n                    caller.emit(`${ns}:${type}`, payload);\n                    return;\n                }\n                caller.emit(type, payload);\n            },\n            [LSPMSG_SYNC]: ({ _sync, result }) => {\n                debug(`[sync reply] #${_sync}`, result);\n                if (syncActors.has(_sync)) {\n                    const actor = syncActors.get(_sync);\n                    if (actor) {\n                        if (result?.hasOwnProperty(LSPMSG_ERROR_TAG)) {\n                            actor.reject(result[LSPMSG_ERROR_TAG]);\n                        }\n                        else {\n                            actor.resolve(result);\n                        }\n                        syncActors.delete(_sync);\n                    }\n                }\n            },\n            ...userModel\n        });\n        if (isShadowMode) {\n            await readyDeferred.promise;\n            return JSON.parse(JSON.stringify(this._pluginLocal?.toJSON()));\n        }\n        const pm = new _postmate__WEBPACK_IMPORTED_MODULE_1__.Model(model);\n        const handshake = pm.sendHandshakeReply();\n        this._status = 'pending';\n        await handshake.then((refParent) => {\n            this._child = refParent;\n            this._connected = true;\n            this._call = async (type, payload = {}, actor) => {\n                if (actor) {\n                    const tag = ++syncTag;\n                    syncActors.set(tag, actor);\n                    payload._sync = tag;\n                    actor.setTag(`async call #${tag}`);\n                    debug('async call #', tag);\n                }\n                refParent.emit(LSPMSGFn(model.baseInfo.id), { type, payload });\n                return actor?.promise;\n            };\n            this._callUserModel = async (type, payload) => {\n                try {\n                    model[type](payload);\n                }\n                catch (e) {\n                    debug(`[model method] #${type} not existed`);\n                }\n            };\n            // actors GC\n            syncGCTimer = setInterval(() => {\n                if (syncActors.size > 100) {\n                    for (const [k, v] of syncActors) {\n                        if (v.settled) {\n                            syncActors.delete(k);\n                        }\n                    }\n                }\n            }, 1000 * 60 * 30);\n        }).finally(() => {\n            this._status = undefined;\n        });\n        await readyDeferred.promise;\n        return model.baseInfo;\n    }\n    async call(type, payload = {}) {\n        return this._call?.call(this, type, payload);\n    }\n    async callAsync(type, payload = {}) {\n        const actor = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.deferred)(1000 * 10);\n        return this._call?.call(this, type, payload, actor);\n    }\n    async callUserModel(type, payload = {}) {\n        return this._callUserModel?.call(this, type, payload);\n    }\n    // run in host\n    async _setupIframeSandbox() {\n        const pl = this._pluginLocal;\n        const id = pl.id;\n        const url = new URL(pl.options.entry);\n        url.searchParams\n            .set(`__v__`, _helpers__WEBPACK_IMPORTED_MODULE_3__.IS_DEV ? Date.now().toString() : pl.options.version);\n        // clear zombie sandbox\n        const zb = document.querySelector(`#${id}`);\n        if (zb)\n            zb.parentElement.removeChild(zb);\n        const cnt = document.createElement('div');\n        cnt.classList.add('lsp-iframe-sandbox-container');\n        cnt.id = id;\n        // TODO: apply any container layout data\n        {\n            const mainLayoutInfo = this._pluginLocal.settings.get('layout')?.[0];\n            if (mainLayoutInfo) {\n                cnt.dataset.inited_layout = 'true';\n                const { width, height, left, top } = mainLayoutInfo;\n                Object.assign(cnt.style, {\n                    width: width + 'px', height: height + 'px',\n                    left: left + 'px', top: top + 'px'\n                });\n            }\n        }\n        document.body.appendChild(cnt);\n        const pt = new _postmate__WEBPACK_IMPORTED_MODULE_1__.Postmate({\n            id: id + '_iframe', container: cnt, url: url.href,\n            classListArray: ['lsp-iframe-sandbox'],\n            model: { baseInfo: JSON.parse(JSON.stringify(pl.toJSON())) }\n        });\n        let handshake = pt.sendHandshake();\n        this._status = 'pending';\n        // timeout for handshake\n        let timer;\n        return new Promise((resolve, reject) => {\n            timer = setTimeout(() => {\n                reject(new Error(`handshake Timeout`));\n            }, 3 * 1000); // 3secs\n            handshake.then((refChild) => {\n                this._parent = refChild;\n                this._connected = true;\n                this.emit('connected');\n                refChild.on(LSPMSGFn(pl.id), ({ type, payload }) => {\n                    debug(`[call from plugin] `, type, payload);\n                    this._pluginLocal?.emit(type, payload || {});\n                });\n                this._call = async (...args) => {\n                    // parent all will get message before handshaked\n                    await refChild.call(LSPMSGFn(pl.id), {\n                        type: args[0], payload: Object.assign(args[1] || {}, {\n                            $$pid: pl.id\n                        })\n                    });\n                };\n                this._callUserModel = async (type, payload) => {\n                    if (type.startsWith(FLAG_AWAIT)) {\n                        // TODO: attach payload with method call\n                        return await refChild.get(type.replace(FLAG_AWAIT, ''));\n                    }\n                    else {\n                        refChild.call(type, payload);\n                    }\n                };\n                resolve(null);\n            }).catch(e => {\n                reject(e);\n            }).finally(() => {\n                clearTimeout(timer);\n            });\n        }).catch(e => {\n            debug('[iframe sandbox] error', e);\n            throw e;\n        }).finally(() => {\n            this._status = undefined;\n        });\n    }\n    async _setupShadowSandbox() {\n        const pl = this._pluginLocal;\n        const shadow = this._shadow = new _LSPlugin_shadow__WEBPACK_IMPORTED_MODULE_4__.LSPluginShadowFrame(pl);\n        try {\n            this._status = 'pending';\n            await shadow.load();\n            this._connected = true;\n            this.emit('connected');\n            this._call = async (type, payload = {}, actor) => {\n                actor && (payload.actor = actor);\n                // @ts-ignore Call in same thread\n                this._pluginLocal?.emit(type, Object.assign(payload, {\n                    $$pid: pl.id\n                }));\n                return actor?.promise;\n            };\n            this._callUserModel = async (...args) => {\n                let type = args[0];\n                if (type?.startsWith(FLAG_AWAIT)) {\n                    type = type.replace(FLAG_AWAIT, '');\n                }\n                const payload = args[1] || {};\n                const fn = this._userModel[type];\n                if (typeof fn === 'function') {\n                    await fn.call(null, payload);\n                }\n            };\n        }\n        catch (e) {\n            debug('[shadow sandbox] error', e);\n            throw e;\n        }\n        finally {\n            this._status = undefined;\n        }\n    }\n    _extendUserModel(model) {\n        return Object.assign(this._userModel, model);\n    }\n    _getSandboxIframeContainer() {\n        return this._parent?.frame.parentNode;\n    }\n    _getSandboxShadowContainer() {\n        return this._shadow?.frame.parentNode;\n    }\n    _getSandboxIframeRoot() {\n        return this._parent?.frame;\n    }\n    _getSandboxShadowRoot() {\n        return this._shadow?.frame;\n    }\n    set debugTag(value) {\n        this._debugTag = value;\n    }\n    async destroy() {\n        let root = null;\n        if (this._parent) {\n            root = this._getSandboxIframeContainer();\n            await this._parent.destroy();\n        }\n        if (this._shadow) {\n            root = this._getSandboxShadowContainer();\n            this._shadow.destroy();\n        }\n        root?.parentNode.removeChild(root);\n    }\n}\n\n\n\n//# sourceURL=webpack://LSPlugin/./src/LSPlugin.caller.ts?");

/***/ }),

/***/ "./src/LSPlugin.core.ts":
/*!******************************!*\
  !*** ./src/LSPlugin.core.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PluginLocal\": () => (/* binding */ PluginLocal),\n/* harmony export */   \"pluginHelpers\": () => (/* reexport module object */ _helpers__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   \"setupPluginCore\": () => (/* binding */ setupPluginCore)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LSPlugin.caller */ \"./src/LSPlugin.caller.ts\");\n/* harmony import */ var snake_case__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! snake-case */ \"./node_modules/snake-case/dist.es2015/index.js\");\n\n\n\n\n\n\nconst debug = debug__WEBPACK_IMPORTED_MODULE_2___default()('LSPlugin:core');\nconst DIR_PLUGINS = 'plugins';\n/**\n * User settings\n */\nclass PluginSettings extends (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default()) {\n    _userPluginSettings;\n    _settings = {\n        disabled: false\n    };\n    constructor(_userPluginSettings) {\n        super();\n        this._userPluginSettings = _userPluginSettings;\n        Object.assign(this._settings, _userPluginSettings);\n    }\n    get(k) {\n        return this._settings[k];\n    }\n    set(k, v) {\n        const o = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.deepMerge)({}, this._settings);\n        if (typeof k === 'string') {\n            if (this._settings[k] == v)\n                return;\n            this._settings[k] = v;\n        }\n        else if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isObject)(k)) {\n            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.deepMerge)(this._settings, k);\n        }\n        else {\n            return;\n        }\n        this.emit('change', Object.assign({}, this._settings), o);\n    }\n    set settings(value) {\n        this._settings = value;\n    }\n    get settings() {\n        return this._settings;\n    }\n    toJSON() {\n        return this._settings;\n    }\n}\nclass PluginLogger extends (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default()) {\n    _tag;\n    _logs = [];\n    constructor(_tag) {\n        super();\n        this._tag = _tag;\n    }\n    write(type, payload) {\n        let msg = payload.reduce((ac, it) => {\n            if (it && it instanceof Error) {\n                ac += `${it.message} ${it.stack}`;\n            }\n            else {\n                ac += it.toString();\n            }\n            return ac;\n        }, `[${this._tag}][${new Date().toLocaleTimeString()}] `);\n        this._logs.push([type, msg]);\n        this.emit('change');\n    }\n    clear() {\n        this._logs = [];\n        this.emit('change');\n    }\n    info(...args) {\n        this.write('INFO', args);\n    }\n    error(...args) {\n        this.write('ERROR', args);\n    }\n    warn(...args) {\n        this.write('WARN', args);\n    }\n    toJSON() {\n        return this._logs;\n    }\n}\nvar PluginLocalLoadStatus;\n(function (PluginLocalLoadStatus) {\n    PluginLocalLoadStatus[\"LOADING\"] = \"loading\";\n    PluginLocalLoadStatus[\"UNLOADING\"] = \"unloading\";\n    PluginLocalLoadStatus[\"LOADED\"] = \"loaded\";\n    PluginLocalLoadStatus[\"UNLOADED\"] = \"unload\";\n    PluginLocalLoadStatus[\"ERROR\"] = \"error\";\n})(PluginLocalLoadStatus || (PluginLocalLoadStatus = {}));\nfunction initUserSettingsHandlers(pluginLocal) {\n    const _ = (label) => `settings:${label}`;\n    pluginLocal.on(_('update'), (attrs) => {\n        if (!attrs)\n            return;\n        pluginLocal.settings?.set(attrs);\n    });\n}\nfunction initMainUIHandlers(pluginLocal) {\n    const _ = (label) => `main-ui:${label}`;\n    pluginLocal.on(_('visible'), ({ visible, toggle, cursor, autoFocus }) => {\n        const el = pluginLocal.getMainUIContainer();\n        el?.classList[toggle ? 'toggle' : (visible ? 'add' : 'remove')]('visible');\n        // pluginLocal.caller!.callUserModel(LSPMSG, { type: _('visible'), payload: visible })\n        // auto focus frame\n        if (visible) {\n            if (!pluginLocal.shadow && el && (autoFocus !== false)) {\n                el.querySelector('iframe')?.contentWindow?.focus();\n            }\n        }\n        if (cursor) {\n            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)('restore_editing_cursor');\n        }\n    });\n    pluginLocal.on(_('attrs'), (attrs) => {\n        const el = pluginLocal.getMainUIContainer();\n        Object.entries(attrs).forEach(([k, v]) => {\n            el?.setAttribute(k, v);\n            if (k === 'draggable' && v) {\n                pluginLocal._dispose(pluginLocal._setupDraggableContainer(el, {\n                    title: pluginLocal.options.name,\n                    close: () => {\n                        pluginLocal.caller.call('sys:ui:visible', { toggle: true });\n                    }\n                }));\n            }\n            if (k === 'resizable' && v) {\n                pluginLocal._dispose(pluginLocal._setupResizableContainer(el));\n            }\n        });\n    });\n    pluginLocal.on(_('style'), (style) => {\n        const el = pluginLocal.getMainUIContainer();\n        const isInitedLayout = !!el.dataset.inited_layout;\n        Object.entries(style).forEach(([k, v]) => {\n            if (isInitedLayout && [\n                'left', 'top', 'bottom', 'right', 'width', 'height'\n            ].includes(k)) {\n                return;\n            }\n            el.style[k] = v;\n        });\n    });\n}\nfunction initProviderHandlers(pluginLocal) {\n    let _ = (label) => `provider:${label}`;\n    let themed = false;\n    pluginLocal.on(_('theme'), (theme) => {\n        pluginLocal.themeMgr.registerTheme(pluginLocal.id, theme);\n        if (!themed) {\n            pluginLocal._dispose(() => {\n                pluginLocal.themeMgr.unregisterTheme(pluginLocal.id);\n            });\n            themed = true;\n        }\n    });\n    pluginLocal.on(_('style'), (style) => {\n        let key;\n        if (typeof style !== 'string') {\n            key = style.key;\n            style = style.style;\n        }\n        if (!style || !style.trim())\n            return;\n        pluginLocal._dispose((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.setupInjectedStyle)(style, {\n            'data-injected-style': key ? `${key}-${pluginLocal.id}` : '',\n            'data-ref': pluginLocal.id\n        }));\n    });\n    pluginLocal.on(_('ui'), (ui) => {\n        pluginLocal._onHostMounted(() => {\n            pluginLocal._dispose(_helpers__WEBPACK_IMPORTED_MODULE_1__.setupInjectedUI.call(pluginLocal, ui, Object.assign({\n                'data-ref': pluginLocal.id\n            }, ui.attrs || {}), ({ el, float }) => {\n                if (!float)\n                    return;\n                const identity = el.dataset.identity;\n                pluginLocal.layoutCore.move_container_to_top(identity);\n            }));\n        });\n    });\n}\nfunction initApiProxyHandlers(pluginLocal) {\n    let _ = (label) => `api:${label}`;\n    pluginLocal.on(_('call'), async (payload) => {\n        let ret;\n        try {\n            ret = await (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)(payload.method, ...payload.args);\n        }\n        catch (e) {\n            ret = {\n                [_LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.LSPMSG_ERROR_TAG]: e,\n            };\n        }\n        const { _sync } = payload;\n        if (pluginLocal.shadow) {\n            if (payload.actor) {\n                payload.actor.resolve(ret);\n            }\n            return;\n        }\n        if (_sync != null) {\n            const reply = (result) => {\n                pluginLocal.caller?.callUserModel(_LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.LSPMSG_SYNC, {\n                    result, _sync\n                });\n            };\n            Promise.resolve(ret).then(reply, reply);\n        }\n    });\n}\nfunction convertToLSPResource(fullUrl, dotPluginRoot) {\n    if (dotPluginRoot &&\n        fullUrl.startsWith(_helpers__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_FILE + dotPluginRoot)) {\n        fullUrl = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.safetyPathJoin)(_helpers__WEBPACK_IMPORTED_MODULE_1__.URL_LSP, fullUrl.substr(_helpers__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_FILE.length + dotPluginRoot.length));\n    }\n    return fullUrl;\n}\nclass IllegalPluginPackageError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = IllegalPluginPackageError.name;\n    }\n}\nclass ExistedImportedPluginPackageError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = ExistedImportedPluginPackageError.name;\n    }\n}\n/**\n * Host plugin for local\n */\nclass PluginLocal extends (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default()) {\n    _options;\n    _themeMgr;\n    _ctx;\n    _disposes = [];\n    _id;\n    _status = PluginLocalLoadStatus.UNLOADED;\n    _loadErr;\n    _localRoot;\n    _dotSettingsFile;\n    _caller;\n    /**\n     * @param _options\n     * @param _themeMgr\n     * @param _ctx\n     */\n    constructor(_options, _themeMgr, _ctx) {\n        super();\n        this._options = _options;\n        this._themeMgr = _themeMgr;\n        this._ctx = _ctx;\n        this._id = _options.key || (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.genID)();\n        initUserSettingsHandlers(this);\n        initMainUIHandlers(this);\n        initProviderHandlers(this);\n        initApiProxyHandlers(this);\n    }\n    async _setupUserSettings(reload) {\n        const { _options } = this;\n        const logger = _options.logger = new PluginLogger('Loader');\n        if (_options.settings && !reload) {\n            return;\n        }\n        try {\n            const loadFreshSettings = () => (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)('load_plugin_user_settings', this.id);\n            const [userSettingsFilePath, userSettings] = await loadFreshSettings();\n            this._dotSettingsFile = userSettingsFilePath;\n            let settings = _options.settings;\n            if (!settings) {\n                settings = _options.settings = new PluginSettings(userSettings);\n            }\n            if (reload) {\n                settings.settings = userSettings;\n                return;\n            }\n            const handler = async (a, b) => {\n                debug('Settings changed', this.debugTag, a);\n                if (!a.disabled && b.disabled) {\n                    // Enable plugin\n                    const [, freshSettings] = await loadFreshSettings();\n                    freshSettings.disabled = false;\n                    a = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.deepMerge)(a, freshSettings);\n                    settings.settings = a;\n                    await this.load();\n                }\n                if (a.disabled && !b.disabled) {\n                    // Disable plugin\n                    const [, freshSettings] = await loadFreshSettings();\n                    freshSettings.disabled = true;\n                    a = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.deepMerge)(a, freshSettings);\n                    await this.unload();\n                }\n                if (a) {\n                    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)(`save_plugin_user_settings`, this.id, a);\n                }\n            };\n            // observe settings\n            settings.on('change', handler);\n            return () => { };\n        }\n        catch (e) {\n            debug('[load plugin user settings Error]', e);\n            logger?.error(e);\n        }\n    }\n    getMainUIContainer() {\n        if (this.shadow) {\n            return this.caller?._getSandboxShadowContainer();\n        }\n        return this.caller?._getSandboxIframeContainer();\n    }\n    _resolveResourceFullUrl(filePath, localRoot) {\n        if (!filePath?.trim())\n            return;\n        localRoot = localRoot || this._localRoot;\n        const reg = /^(http|file)/;\n        if (!reg.test(filePath)) {\n            const url = _helpers__WEBPACK_IMPORTED_MODULE_1__.path.join(localRoot, filePath);\n            filePath = reg.test(url) ? url : (_helpers__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_FILE + url);\n        }\n        return (!this.options.effect && this.isInstalledInDotRoot) ?\n            convertToLSPResource(filePath, this.dotPluginsRoot) : filePath;\n    }\n    async _preparePackageConfigs() {\n        const { url } = this._options;\n        let pkg;\n        try {\n            if (!url) {\n                throw new Error('Can not resolve package config location');\n            }\n            debug('prepare package root', url);\n            pkg = await (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)('load_plugin_config', url);\n            if (!pkg || (pkg = JSON.parse(pkg), !pkg)) {\n                throw new Error(`Parse package config error #${url}/package.json`);\n            }\n        }\n        catch (e) {\n            throw new IllegalPluginPackageError(e.message);\n        }\n        const localRoot = this._localRoot = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.safetyPathNormalize)(url);\n        const logseq = pkg.logseq || {};\n        ['name', 'author', 'repository', 'version',\n            'description', 'repo', 'title', 'effect',\n        ].concat(!this.isInstalledInDotRoot ? ['devEntry'] : []).forEach(k => {\n            this._options[k] = pkg[k];\n        });\n        const validateEntry = (main) => main && /\\.(js|html)$/.test(main);\n        // Entry from main\n        const entry = logseq.entry || logseq.main || pkg.main;\n        if (validateEntry(entry)) { // Theme has no main\n            this._options.entry = this._resolveResourceFullUrl(entry, localRoot);\n            this._options.devEntry = logseq.devEntry;\n            if (logseq.mode) {\n                this._options.mode = logseq.mode;\n            }\n        }\n        const title = logseq.title || pkg.title;\n        const icon = logseq.icon || pkg.icon;\n        this._options.title = title;\n        this._options.icon = icon &&\n            this._resolveResourceFullUrl(icon);\n        this._options.theme = Boolean(logseq.theme || !!logseq.themes);\n        // TODO: strategy for Logseq plugins center\n        if (this.isInstalledInDotRoot) {\n            this._id = _helpers__WEBPACK_IMPORTED_MODULE_1__.path.basename(localRoot);\n        }\n        else {\n            if (logseq.id) {\n                this._id = logseq.id;\n            }\n            else {\n                logseq.id = this.id;\n                try {\n                    await (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)('save_plugin_config', url, { ...pkg, logseq });\n                }\n                catch (e) {\n                    debug('[save plugin ID Error] ', e);\n                }\n            }\n        }\n        // Validate id\n        const { registeredPlugins, isRegistering } = this._ctx;\n        if (isRegistering && registeredPlugins.has(logseq.id)) {\n            throw new ExistedImportedPluginPackageError('prepare package Error');\n        }\n        return async () => {\n            try {\n                // 0. Install Themes\n                let themes = logseq.themes;\n                if (themes) {\n                    await this._loadConfigThemes(Array.isArray(themes) ? themes : [themes]);\n                }\n            }\n            catch (e) {\n                debug('[prepare package effect Error]', e);\n            }\n        };\n    }\n    async _tryToNormalizeEntry() {\n        let { entry, settings, devEntry } = this.options;\n        devEntry = devEntry || settings?.get('_devEntry');\n        if (devEntry) {\n            this._options.entry = devEntry;\n            return;\n        }\n        if (!entry.endsWith('.js'))\n            return;\n        let dirPathInstalled = null;\n        let tmp_file_method = 'write_user_tmp_file';\n        if (this.isInstalledInDotRoot) {\n            tmp_file_method = 'write_dotdir_file';\n            dirPathInstalled = this._localRoot.replace(this.dotPluginsRoot, '');\n            dirPathInstalled = _helpers__WEBPACK_IMPORTED_MODULE_1__.path.join(DIR_PLUGINS, dirPathInstalled);\n        }\n        let sdkPathRoot = await (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getSDKPathRoot)();\n        let entryPath = await (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)(tmp_file_method, `${this._id}_index.html`, `<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>logseq plugin entry</title>\n    <script src=\"${sdkPathRoot}/lsplugin.user.js\"></script>\n  </head>\n  <body>\n  <div id=\"app\"></div>\n  <script src=\"${entry}\"></script>\n  </body>\n</html>`, dirPathInstalled);\n        entry = convertToLSPResource((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.withFileProtocol)(_helpers__WEBPACK_IMPORTED_MODULE_1__.path.normalize(entryPath)), this.dotPluginsRoot);\n        this._options.entry = entry;\n    }\n    async _loadConfigThemes(themes) {\n        themes.forEach((options) => {\n            if (!options.url)\n                return;\n            if (!options.url.startsWith('http') && this._localRoot) {\n                options.url = _helpers__WEBPACK_IMPORTED_MODULE_1__.path.join(this._localRoot, options.url);\n                // file:// for native\n                if (!options.url.startsWith('file:')) {\n                    options.url = 'assets://' + options.url;\n                }\n            }\n            // @ts-ignore\n            this.emit('provider:theme', options);\n        });\n    }\n    _persistMainUILayoutData(e) {\n        const layouts = this.settings.get('layouts') || [];\n        layouts[0] = e;\n        this.settings.set('layout', layouts);\n    }\n    _setupDraggableContainer(el, opts = {}) {\n        const ds = el.dataset;\n        if (ds.inited_draggable)\n            return;\n        if (!ds.identity) {\n            ds.identity = 'dd-' + (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.genID)();\n        }\n        const isInjectedUI = !!opts.key;\n        const handle = document.createElement('div');\n        handle.classList.add('draggable-handle');\n        handle.innerHTML = `\n      <div class=\"th\">\n        <div class=\"l\"><h3>${opts.title || ''}</h3></div>\n        <div class=\"r\">\n          <a class=\"button x\"><i class=\"ti ti-x\"></i></a>\n        </div>\n      </div>\n    `;\n        handle.querySelector('.x')\n            .addEventListener('click', (e) => {\n            opts?.close?.();\n            e.stopPropagation();\n        }, false);\n        handle.addEventListener('mousedown', (e) => {\n            const target = e.target;\n            if (target?.closest('.r')) {\n                e.stopPropagation();\n                e.preventDefault();\n                return;\n            }\n        }, false);\n        el.prepend(handle);\n        // move to top\n        el.addEventListener('mousedown', (e) => {\n            this.layoutCore.move_container_to_top(ds.identity);\n        }, true);\n        const setTitle = (title) => {\n            handle.querySelector('h3').textContent = title;\n        };\n        const dispose = this.layoutCore.setup_draggable_container_BANG_(el, !isInjectedUI ? this._persistMainUILayoutData.bind(this) : () => { });\n        ds.inited_draggable = 'true';\n        if (opts.title) {\n            setTitle(opts.title);\n        }\n        // click outside\n        let removeOutsideListener = null;\n        if (ds.close === 'outside') {\n            const handler = (e) => {\n                const target = e.target;\n                if (!el.contains(target)) {\n                    opts.close();\n                }\n            };\n            document.addEventListener('click', handler, false);\n            removeOutsideListener = () => {\n                document.removeEventListener('click', handler);\n            };\n        }\n        return () => {\n            dispose();\n            removeOutsideListener?.();\n        };\n    }\n    _setupResizableContainer(el, key) {\n        const ds = el.dataset;\n        if (ds.inited_resizable)\n            return;\n        if (!ds.identity) {\n            ds.identity = 'dd-' + (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.genID)();\n        }\n        const handle = document.createElement('div');\n        handle.classList.add('resizable-handle');\n        el.prepend(handle);\n        // @ts-ignore\n        const layoutCore = window.frontend.modules.layout.core;\n        const dispose = layoutCore.setup_resizable_container_BANG_(el, !key ? this._persistMainUILayoutData.bind(this) : () => { });\n        ds.inited_resizable = 'true';\n        return dispose;\n    }\n    async load(opts) {\n        if (this.pending) {\n            return;\n        }\n        this._status = PluginLocalLoadStatus.LOADING;\n        this._loadErr = undefined;\n        try {\n            // if (!this.options.entry) { // Themes package no entry field\n            // }\n            let installPackageThemes = await this._preparePackageConfigs();\n            this._dispose(await this._setupUserSettings(opts?.reload));\n            if (!this.disabled) {\n                await installPackageThemes.call(null);\n            }\n            if (this.disabled || !this.options.entry) {\n                return;\n            }\n            await this._tryToNormalizeEntry();\n            this._caller = new _LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.LSPluginCaller(this);\n            await this._caller.connectToChild();\n            const readyFn = () => {\n                this._caller?.callUserModel(_LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.LSPMSG_READY, { pid: this.id });\n            };\n            if (opts?.indicator) {\n                opts.indicator.promise.then(readyFn);\n            }\n            else {\n                readyFn();\n            }\n            this._dispose(async () => {\n                await this._caller?.destroy();\n            });\n        }\n        catch (e) {\n            debug('[Load Plugin Error] ', e);\n            this.logger?.error(e);\n            this._status = PluginLocalLoadStatus.ERROR;\n            this._loadErr = e;\n        }\n        finally {\n            if (!this._loadErr) {\n                if (this.disabled) {\n                    this._status = PluginLocalLoadStatus.UNLOADED;\n                }\n                else {\n                    this._status = PluginLocalLoadStatus.LOADED;\n                }\n            }\n        }\n    }\n    async reload() {\n        if (this.pending) {\n            return;\n        }\n        this._ctx.emit('beforereload', this);\n        await this.unload();\n        await this.load({ reload: true });\n        this._ctx.emit('reloaded', this);\n    }\n    /**\n     * @param unregister If true delete plugin files\n     */\n    async unload(unregister = false) {\n        if (this.pending) {\n            return;\n        }\n        if (unregister) {\n            await this.unload();\n            if (this.isInstalledInDotRoot) {\n                this._ctx.emit('unlink-plugin', this.id);\n            }\n            return;\n        }\n        try {\n            this._status = PluginLocalLoadStatus.UNLOADING;\n            const eventBeforeUnload = { unregister };\n            // sync call\n            try {\n                await this._caller?.callUserModel((0,_LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.AWAIT_LSPMSGFn)(_LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.LSPMSG_BEFORE_UNLOAD), eventBeforeUnload);\n                this.emit('beforeunload', eventBeforeUnload);\n            }\n            catch (e) {\n                console.error('[beforeunload Error]', e);\n            }\n            await this.dispose();\n            this.emit('unloaded');\n        }\n        catch (e) {\n            debug('[plugin unload Error]', e);\n            return false;\n        }\n        finally {\n            this._status = PluginLocalLoadStatus.UNLOADED;\n        }\n    }\n    async dispose() {\n        for (const fn of this._disposes) {\n            try {\n                fn && (await fn());\n            }\n            catch (e) {\n                console.error(this.debugTag, 'dispose Error', e);\n            }\n        }\n        // clear\n        this._disposes = [];\n    }\n    _dispose(fn) {\n        if (!fn)\n            return;\n        this._disposes.push(fn);\n    }\n    _onHostMounted(callback) {\n        const actor = this._ctx.hostMountedActor;\n        if (!actor || actor.settled) {\n            callback();\n        }\n        else {\n            actor?.promise.then(callback);\n        }\n    }\n    get layoutCore() {\n        // @ts-ignore\n        return window.frontend.modules.layout.core;\n    }\n    get isInstalledInDotRoot() {\n        const dotRoot = this.dotConfigRoot;\n        const plgRoot = this.localRoot;\n        return dotRoot && plgRoot && plgRoot.startsWith(dotRoot);\n    }\n    get loaded() {\n        return this._status === PluginLocalLoadStatus.LOADED;\n    }\n    get pending() {\n        return [PluginLocalLoadStatus.LOADING, PluginLocalLoadStatus.UNLOADING]\n            .includes(this._status);\n    }\n    get status() {\n        return this._status;\n    }\n    get settings() {\n        return this.options.settings;\n    }\n    get logger() {\n        return this.options.logger;\n    }\n    get disabled() {\n        return this.settings?.get('disabled');\n    }\n    get caller() {\n        return this._caller;\n    }\n    get id() {\n        return this._id;\n    }\n    get shadow() {\n        return this.options.mode === 'shadow';\n    }\n    get options() {\n        return this._options;\n    }\n    get themeMgr() {\n        return this._themeMgr;\n    }\n    get debugTag() {\n        const name = this._options?.name;\n        return `#${this._id} ${name ?? ''}`;\n    }\n    get localRoot() {\n        return this._localRoot || this._options.url;\n    }\n    get loadErr() {\n        return this._loadErr;\n    }\n    get dotConfigRoot() {\n        return _helpers__WEBPACK_IMPORTED_MODULE_1__.path.normalize(this._ctx.options.dotConfigRoot);\n    }\n    get dotSettingsFile() {\n        return this._dotSettingsFile;\n    }\n    get dotPluginsRoot() {\n        return _helpers__WEBPACK_IMPORTED_MODULE_1__.path.join(this.dotConfigRoot, DIR_PLUGINS);\n    }\n    toJSON() {\n        const json = { ...this.options };\n        json.id = this.id;\n        json.err = this.loadErr;\n        json.usf = this.dotSettingsFile;\n        json.iir = this.isInstalledInDotRoot;\n        json.lsr = this._resolveResourceFullUrl('');\n        return json;\n    }\n}\n/**\n * Host plugin core\n */\nclass LSPluginCore extends (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default()) {\n    _options;\n    _isRegistering = false;\n    _readyIndicator;\n    _hostMountedActor = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.deferred)();\n    _userPreferences = {};\n    _registeredThemes = new Map();\n    _registeredPlugins = new Map();\n    _currentTheme;\n    /**\n     * @param _options\n     */\n    constructor(_options) {\n        super();\n        this._options = _options;\n    }\n    async loadUserPreferences() {\n        try {\n            const settings = await (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)(`load_user_preferences`);\n            if (settings) {\n                Object.assign(this._userPreferences, settings);\n            }\n        }\n        catch (e) {\n            debug('[load user preferences Error]', e);\n        }\n    }\n    async saveUserPreferences(settings) {\n        try {\n            if (settings) {\n                Object.assign(this._userPreferences, settings);\n            }\n            await (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.invokeHostExportedApi)(`save_user_preferences`, this._userPreferences);\n        }\n        catch (e) {\n            debug('[save user preferences Error]', e);\n        }\n    }\n    async activateUserPreferences() {\n        const { theme } = this._userPreferences;\n        // 0. theme\n        if (theme) {\n            await this.selectTheme(theme, false);\n        }\n    }\n    /**\n     * @param plugins\n     * @param initial\n     */\n    async register(plugins, initial = false) {\n        if (!Array.isArray(plugins)) {\n            await this.register([plugins]);\n            return;\n        }\n        const perfTable = new Map();\n        const debugPerfInfo = () => {\n            const data = Array.from(perfTable.values()).reduce((ac, it) => {\n                const { options, status, disabled } = it.o;\n                ac[it.o.id] = {\n                    name: options.name,\n                    entry: options.entry,\n                    status: status,\n                    enabled: typeof disabled === 'boolean' ? (!disabled ? '🟢' : '⚫️') : '🔴',\n                    perf: !it.e ? it.o.loadErr : `${(it.e - it.s).toFixed(2)}ms`\n                };\n                return ac;\n            }, {});\n            console.table(data);\n        };\n        // @ts-ignore\n        window.__debugPluginsPerfInfo = debugPerfInfo;\n        try {\n            this._isRegistering = true;\n            const userConfigRoot = this._options.dotConfigRoot;\n            const readyIndicator = this._readyIndicator = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.deferred)();\n            await this.loadUserPreferences();\n            const externals = new Set(this._userPreferences.externals || []);\n            if (initial) {\n                plugins = plugins.concat([...externals].filter(url => {\n                    return !plugins.length || plugins.every((p) => !p.entry && (p.url !== url));\n                }).map(url => ({ url })));\n            }\n            for (const pluginOptions of plugins) {\n                const { url } = pluginOptions;\n                const pluginLocal = new PluginLocal(pluginOptions, this, this);\n                const perfInfo = { o: pluginLocal, s: performance.now(), e: 0 };\n                perfTable.set(pluginLocal.id, perfInfo);\n                await pluginLocal.load({ indicator: readyIndicator });\n                const { loadErr } = pluginLocal;\n                if (loadErr) {\n                    debug(`[Failed LOAD Plugin] #`, pluginOptions);\n                    this.emit('error', loadErr);\n                    if (loadErr instanceof IllegalPluginPackageError ||\n                        loadErr instanceof ExistedImportedPluginPackageError) {\n                        // TODO: notify global log system?\n                        continue;\n                    }\n                }\n                perfInfo.e = performance.now();\n                pluginLocal.settings?.on('change', (a) => {\n                    this.emit('settings-changed', pluginLocal.id, a);\n                    pluginLocal.caller?.callUserModel(_LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.LSPMSG_SETTINGS, { payload: a });\n                });\n                this._registeredPlugins.set(pluginLocal.id, pluginLocal);\n                this.emit('registered', pluginLocal);\n                // external plugins\n                if (!pluginLocal.isInstalledInDotRoot) {\n                    externals.add(url);\n                }\n            }\n            await this.saveUserPreferences({ externals: Array.from(externals) });\n            await this.activateUserPreferences();\n            readyIndicator.resolve('ready');\n        }\n        catch (e) {\n            console.error(e);\n        }\n        finally {\n            this._isRegistering = false;\n            debugPerfInfo();\n        }\n    }\n    async reload(plugins) {\n        if (!Array.isArray(plugins)) {\n            await this.reload([plugins]);\n            return;\n        }\n        for (const identity of plugins) {\n            try {\n                const p = this.ensurePlugin(identity);\n                await p.reload();\n            }\n            catch (e) {\n                debug(e);\n            }\n        }\n    }\n    async unregister(plugins) {\n        if (!Array.isArray(plugins)) {\n            await this.unregister([plugins]);\n            return;\n        }\n        const unregisteredExternals = [];\n        for (const identity of plugins) {\n            const p = this.ensurePlugin(identity);\n            if (!p.isInstalledInDotRoot) {\n                unregisteredExternals.push(p.options.url);\n            }\n            await p.unload(true);\n            this._registeredPlugins.delete(identity);\n            this.emit('unregistered', identity);\n        }\n        let externals = this._userPreferences.externals || [];\n        if (externals.length && unregisteredExternals.length) {\n            await this.saveUserPreferences({\n                externals: externals.filter((it) => {\n                    return !unregisteredExternals.includes(it);\n                })\n            });\n        }\n    }\n    async enable(plugin) {\n        const p = this.ensurePlugin(plugin);\n        if (p.pending)\n            return;\n        this.emit('beforeenable');\n        p.settings?.set('disabled', false);\n        this.emit('enabled', p.id);\n    }\n    async disable(plugin) {\n        const p = this.ensurePlugin(plugin);\n        if (p.pending)\n            return;\n        this.emit('beforedisable');\n        p.settings?.set('disabled', true);\n        this.emit('disabled', p.id);\n    }\n    async _hook(ns, type, payload, pid) {\n        for (const [_, p] of this._registeredPlugins) {\n            if (!pid || pid === p.id) {\n                p.caller?.callUserModel(_LSPlugin_caller__WEBPACK_IMPORTED_MODULE_3__.LSPMSG, {\n                    ns, type: (0,snake_case__WEBPACK_IMPORTED_MODULE_4__.snakeCase)(type), payload\n                });\n            }\n        }\n    }\n    hookApp(type, payload, pid) {\n        this._hook(`hook:app`, type, payload, pid);\n    }\n    hookEditor(type, payload, pid) {\n        this._hook(`hook:editor`, type, payload, pid);\n    }\n    _execDirective(tag, ...params) {\n    }\n    ensurePlugin(plugin) {\n        if (plugin instanceof PluginLocal) {\n            return plugin;\n        }\n        const p = this._registeredPlugins.get(plugin);\n        if (!p) {\n            throw new Error(`plugin #${plugin} not existed.`);\n        }\n        return p;\n    }\n    hostMounted() {\n        this._hostMountedActor.resolve();\n    }\n    get registeredPlugins() {\n        return this._registeredPlugins;\n    }\n    get options() {\n        return this._options;\n    }\n    get readyIndicator() {\n        return this._readyIndicator;\n    }\n    get hostMountedActor() {\n        return this._hostMountedActor;\n    }\n    get isRegistering() {\n        return this._isRegistering;\n    }\n    get themes() {\n        return this._registeredThemes;\n    }\n    async registerTheme(id, opt) {\n        debug('registered Theme #', id, opt);\n        if (!id)\n            return;\n        let themes = this._registeredThemes.get(id);\n        if (!themes) {\n            this._registeredThemes.set(id, themes = []);\n        }\n        themes.push(opt);\n        this.emit('theme-changed', this.themes, { id, ...opt });\n    }\n    async selectTheme(opt, effect = true) {\n        // clear current\n        if (this._currentTheme) {\n            this._currentTheme.dis?.();\n        }\n        const disInjectedTheme = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.setupInjectedTheme)(opt?.url);\n        this.emit('theme-selected', opt);\n        effect && await this.saveUserPreferences({ theme: opt?.url ? opt : null });\n        if (opt?.url) {\n            this._currentTheme = {\n                dis: () => {\n                    disInjectedTheme();\n                    effect && this.saveUserPreferences({ theme: null });\n                }, opt, pid: opt.pid\n            };\n        }\n    }\n    async unregisterTheme(id, effect = true) {\n        debug('unregistered Theme #', id);\n        if (!this._registeredThemes.has(id))\n            return;\n        this._registeredThemes.delete(id);\n        this.emit('theme-changed', this.themes, { id });\n        if (effect && this._currentTheme?.pid == id) {\n            this._currentTheme.dis?.();\n            this._currentTheme = null;\n            // reset current theme\n            this.emit('theme-selected', null);\n        }\n    }\n}\nfunction setupPluginCore(options) {\n    const pluginCore = new LSPluginCore(options);\n    debug('=== 🔗 Setup Logseq Plugin System 🔗 ===');\n    window.LSPluginCore = pluginCore;\n}\n\n\n\n//# sourceURL=webpack://LSPlugin/./src/LSPlugin.core.ts?");

/***/ }),

/***/ "./src/LSPlugin.shadow.ts":
/*!********************************!*\
  !*** ./src/LSPlugin.shadow.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LSPluginShadowFrame\": () => (/* binding */ LSPluginShadowFrame)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _LSPlugin_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LSPlugin.user */ \"./src/LSPlugin.user.ts\");\n\n\n// @ts-ignore\nconst { importHTML, createSandboxContainer } = window.QSandbox || {};\nfunction userFetch(url, opts) {\n    if (!url.startsWith('http')) {\n        url = url.replace('file://', '');\n        return new Promise(async (resolve, reject) => {\n            try {\n                const content = await window.apis.doAction(['readFile', url]);\n                resolve({\n                    text() {\n                        return content;\n                    }\n                });\n            }\n            catch (e) {\n                console.error(e);\n                reject(e);\n            }\n        });\n    }\n    return fetch(url, opts);\n}\nclass LSPluginShadowFrame extends (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default()) {\n    _pluginLocal;\n    _frame;\n    _root;\n    _loaded = false;\n    _unmountFns = [];\n    constructor(_pluginLocal) {\n        super();\n        this._pluginLocal = _pluginLocal;\n        _pluginLocal._dispose(() => {\n            this._unmount();\n        });\n    }\n    async load() {\n        const { name, entry } = this._pluginLocal.options;\n        if (this.loaded || !entry)\n            return;\n        const { template, execScripts } = await importHTML(entry, { fetch: userFetch });\n        this._mount(template, document.body);\n        const sandbox = createSandboxContainer(name, {\n            elementGetter: () => this._root?.firstChild,\n        });\n        const global = sandbox.instance.proxy;\n        global.__shadow_mode__ = true;\n        global.LSPluginLocal = this._pluginLocal;\n        global.LSPluginShadow = this;\n        global.LSPluginUser = global.logseq = new _LSPlugin_user__WEBPACK_IMPORTED_MODULE_1__.LSPluginUser(this._pluginLocal.toJSON(), this._pluginLocal.caller);\n        // TODO: {mount, unmount}\n        const execResult = await execScripts(global, true);\n        this._unmountFns.push(execResult.unmount);\n        this._loaded = true;\n    }\n    _mount(content, container) {\n        const frame = this._frame = document.createElement('div');\n        frame.classList.add('lsp-shadow-sandbox');\n        frame.id = this._pluginLocal.id;\n        this._root = frame.attachShadow({ mode: 'open' });\n        this._root.innerHTML = `<div>${content}</div>`;\n        container.appendChild(frame);\n        this.emit('mounted');\n    }\n    _unmount() {\n        for (const fn of this._unmountFns) {\n            fn && fn.call(null);\n        }\n    }\n    destroy() {\n        this.frame?.parentNode?.removeChild(this.frame);\n    }\n    get loaded() {\n        return this._loaded;\n    }\n    get document() {\n        return this._root?.firstChild;\n    }\n    get frame() {\n        return this._frame;\n    }\n}\n\n\n\n//# sourceURL=webpack://LSPlugin/./src/LSPlugin.shadow.ts?");

/***/ }),

/***/ "./src/LSPlugin.ts":
/*!*************************!*\
  !*** ./src/LSPlugin.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://LSPlugin/./src/LSPlugin.ts?");

/***/ }),

/***/ "./src/LSPlugin.user.ts":
/*!******************************!*\
  !*** ./src/LSPlugin.user.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LSPluginUser\": () => (/* binding */ LSPluginUser),\n/* harmony export */   \"setupPluginUserInstance\": () => (/* binding */ setupPluginUserInstance)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n/* harmony import */ var _LSPlugin_caller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LSPlugin.caller */ \"./src/LSPlugin.caller.ts\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var snake_case__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! snake-case */ \"./node_modules/snake-case/dist.es2015/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _modules_LSPlugin_Storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/LSPlugin.Storage */ \"./src/modules/LSPlugin.Storage.ts\");\n/* harmony import */ var _LSPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LSPlugin */ \"./src/LSPlugin.ts\");\n\n\n\n\n\n\nconst PROXY_CONTINUE = Symbol.for('proxy-continue');\nconst debug = debug__WEBPACK_IMPORTED_MODULE_2___default()('LSPlugin:user');\n/**\n * @param type (key of group commands)\n * @param opts\n * @param action\n */\nfunction registerSimpleCommand(type, opts, action) {\n    if (typeof action !== 'function') {\n        return false;\n    }\n    const { key, label, desc, palette, keybinding } = opts;\n    const eventKey = `SimpleCommandHook${key}${++registeredCmdUid}`;\n    this.Editor['on' + eventKey](action);\n    this.caller?.call(`api:call`, {\n        method: 'register-plugin-simple-command',\n        args: [this.baseInfo.id, [{ key, label, type, desc, keybinding }, ['editor/hook', eventKey]], palette]\n    });\n}\nconst app = {\n    registerCommand: registerSimpleCommand,\n    registerCommandPalette(opts, action) {\n        const { key, label, keybinding } = opts;\n        const group = 'global-palette-command';\n        return registerSimpleCommand.call(this, group, { key, label, palette: true, keybinding }, action);\n    },\n    registerUIItem(type, opts) {\n        const pid = this.baseInfo.id;\n        // opts.key = `${pid}_${opts.key}`\n        this.caller?.call(`api:call`, {\n            method: 'register-plugin-ui-item',\n            args: [pid, type, opts]\n        });\n    },\n    registerPageMenuItem(tag, action) {\n        if (typeof action !== 'function') {\n            return false;\n        }\n        const key = tag + '_' + this.baseInfo.id;\n        const label = tag;\n        const type = 'page-menu-item';\n        registerSimpleCommand.call(this, type, {\n            key, label\n        }, action);\n    },\n    setFullScreen(flag) {\n        const sf = (...args) => this._callWin('setFullScreen', ...args);\n        if (flag === 'toggle') {\n            this._callWin('isFullScreen').then(r => {\n                r ? sf() : sf(true);\n            });\n        }\n        else {\n            flag ? sf(true) : sf();\n        }\n    }\n};\nlet registeredCmdUid = 0;\nconst editor = {\n    registerSlashCommand(tag, actions) {\n        debug('Register slash command #', this.baseInfo.id, tag, actions);\n        if (typeof actions === 'function') {\n            actions = [\n                ['editor/clear-current-slash', false],\n                ['editor/restore-saved-cursor'],\n                ['editor/hook', actions]\n            ];\n        }\n        actions = actions.map((it) => {\n            const [tag, ...args] = it;\n            switch (tag) {\n                case 'editor/hook':\n                    let key = args[0];\n                    let fn = () => {\n                        this.caller?.callUserModel(key);\n                    };\n                    if (typeof key === 'function') {\n                        fn = key;\n                    }\n                    const eventKey = `SlashCommandHook${tag}${++registeredCmdUid}`;\n                    it[1] = eventKey;\n                    // register command listener\n                    this.Editor['on' + eventKey](fn);\n                    break;\n                default:\n            }\n            return it;\n        });\n        this.caller?.call(`api:call`, {\n            method: 'register-plugin-slash-command',\n            args: [this.baseInfo.id, [tag, actions]]\n        });\n    },\n    registerBlockContextMenuItem(tag, action) {\n        if (typeof action !== 'function') {\n            return false;\n        }\n        const key = tag + '_' + this.baseInfo.id;\n        const label = tag;\n        const type = 'block-context-menu-item';\n        registerSimpleCommand.call(this, type, {\n            key, label\n        }, action);\n    },\n    scrollToBlockInPage(pageName, blockId) {\n        const anchor = `block-content-` + blockId;\n        this.App.pushState('page', { name: pageName }, { anchor });\n    }\n};\nconst db = {};\nconst KEY_MAIN_UI = 0;\n/**\n * User plugin instance\n * @public\n */\nclass LSPluginUser extends (eventemitter3__WEBPACK_IMPORTED_MODULE_3___default()) {\n    _baseInfo;\n    _caller;\n    /**\n     * @private\n     */\n    _connected = false;\n    /**\n     * ui frame identities\n     * @private\n     */\n    _ui = new Map();\n    _fileStorage;\n    /**\n     * handler of before unload plugin\n     * @private\n     */\n    _beforeunloadCallback;\n    /**\n     * @param _baseInfo\n     * @param _caller\n     */\n    constructor(_baseInfo, _caller) {\n        super();\n        this._baseInfo = _baseInfo;\n        this._caller = _caller;\n        _caller.on('sys:ui:visible', (payload) => {\n            if (payload?.toggle) {\n                this.toggleMainUI();\n            }\n        });\n        _caller.on('settings:changed', (payload) => {\n            const b = Object.assign({}, this.settings);\n            const a = Object.assign(this._baseInfo.settings, payload);\n            this.emit('settings:changed', { ...a }, b);\n        });\n        _caller.on('beforeunload', async (payload) => {\n            const { actor, ...rest } = payload;\n            const cb = this._beforeunloadCallback;\n            try {\n                cb && await cb(rest);\n                actor?.resolve(null);\n            }\n            catch (e) {\n                console.debug(`${_caller.debugTag} [beforeunload] `, e);\n                actor?.reject(e);\n            }\n        });\n        // modules\n        this._fileStorage = new _modules_LSPlugin_Storage__WEBPACK_IMPORTED_MODULE_4__.LSPluginFileStorage(this);\n    }\n    async ready(model, callback) {\n        if (this._connected)\n            return;\n        try {\n            if (typeof model === 'function') {\n                callback = model;\n                model = {};\n            }\n            let baseInfo = await this._caller.connectToParent(model);\n            baseInfo = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.deepMerge)(this._baseInfo, baseInfo);\n            this._connected = true;\n            if (baseInfo?.id) {\n                this._caller.debugTag = `#${baseInfo.id} [${baseInfo.name}]`;\n            }\n            callback && callback.call(this, baseInfo);\n        }\n        catch (e) {\n            console.error('[LSPlugin Ready Error]', e);\n        }\n    }\n    ensureConnected() {\n        if (!this._connected) {\n            throw new Error('not connected');\n        }\n    }\n    beforeunload(callback) {\n        if (typeof callback !== 'function')\n            return;\n        this._beforeunloadCallback = callback;\n    }\n    provideModel(model) {\n        this.caller._extendUserModel(model);\n        return this;\n    }\n    provideTheme(theme) {\n        this.caller.call('provider:theme', theme);\n        return this;\n    }\n    provideStyle(style) {\n        this.caller.call('provider:style', style);\n        return this;\n    }\n    provideUI(ui) {\n        this.caller.call('provider:ui', ui);\n        return this;\n    }\n    updateSettings(attrs) {\n        this.caller.call('settings:update', attrs);\n        // TODO: update associated baseInfo settings\n    }\n    setMainUIAttrs(attrs) {\n        this.caller.call('main-ui:attrs', attrs);\n    }\n    setMainUIInlineStyle(style) {\n        this.caller.call('main-ui:style', style);\n    }\n    hideMainUI(opts) {\n        const payload = { key: KEY_MAIN_UI, visible: false, cursor: opts?.restoreEditingCursor };\n        this.caller.call('main-ui:visible', payload);\n        this.emit('ui:visible:changed', payload);\n        this._ui.set(payload.key, payload);\n    }\n    showMainUI(opts) {\n        const payload = { key: KEY_MAIN_UI, visible: true, autoFocus: opts?.autoFocus };\n        this.caller.call('main-ui:visible', payload);\n        this.emit('ui:visible:changed', payload);\n        this._ui.set(payload.key, payload);\n    }\n    toggleMainUI() {\n        const payload = { key: KEY_MAIN_UI, toggle: true };\n        const state = this._ui.get(payload.key);\n        if (state && state.visible) {\n            this.hideMainUI();\n        }\n        else {\n            this.showMainUI();\n        }\n    }\n    get isMainUIVisible() {\n        const state = this._ui.get(KEY_MAIN_UI);\n        return Boolean(state && state.visible);\n    }\n    get connected() {\n        return this._connected;\n    }\n    get baseInfo() {\n        return this._baseInfo;\n    }\n    get settings() {\n        return this.baseInfo?.settings;\n    }\n    get caller() {\n        return this._caller;\n    }\n    resolveResourceFullUrl(filePath) {\n        this.ensureConnected();\n        if (!filePath)\n            return;\n        filePath = filePath.replace(/^[.\\\\/]+/, '');\n        return (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.safetyPathJoin)(this._baseInfo.lsr, filePath);\n    }\n    /**\n     * @internal\n     */\n    _makeUserProxy(target, tag) {\n        const that = this;\n        const caller = this.caller;\n        return new Proxy(target, {\n            get(target, propKey, receiver) {\n                const origMethod = target[propKey];\n                return function (...args) {\n                    if (origMethod) {\n                        const ret = origMethod.apply(that, args);\n                        if (ret !== PROXY_CONTINUE)\n                            return;\n                    }\n                    // Handle hook\n                    if (tag) {\n                        const hookMatcher = propKey.toString().match(/^(once|off|on)/i);\n                        if (hookMatcher != null) {\n                            const f = hookMatcher[0].toLowerCase();\n                            const s = hookMatcher.input;\n                            const e = s.slice(f.length);\n                            const type = `hook:${tag}:${(0,snake_case__WEBPACK_IMPORTED_MODULE_5__.snakeCase)(e)}`;\n                            const handler = args[0];\n                            caller[f](type, handler);\n                            return f !== 'off' ? () => (caller.off(type, handler)) : void 0;\n                        }\n                    }\n                    // Call host\n                    return caller.callAsync(`api:call`, {\n                        tag, method: propKey, args: args\n                    });\n                };\n            }\n        });\n    }\n    /**\n     * @param args\n     */\n    _callWin(...args) {\n        return this._caller.callAsync(`api:call`, {\n            method: '_callMainWin',\n            args: args\n        });\n    }\n    /**\n     * The interface methods of {@link IAppProxy}\n     */\n    get App() {\n        return this._makeUserProxy(app, 'app');\n    }\n    get Editor() {\n        return this._makeUserProxy(editor, 'editor');\n    }\n    get DB() {\n        return this._makeUserProxy(db);\n    }\n    get FileStorage() {\n        return this._fileStorage;\n    }\n}\n\n/**\n * @internal\n */\nfunction setupPluginUserInstance(pluginBaseInfo, pluginCaller) {\n    return new LSPluginUser(pluginBaseInfo, pluginCaller);\n}\nif (window.__LSP__HOST__ == null) { // Entry of iframe mode\n    const caller = new _LSPlugin_caller__WEBPACK_IMPORTED_MODULE_1__.LSPluginCaller(null);\n    // @ts-ignore\n    window.logseq = setupPluginUserInstance({}, caller);\n}\n\n\n//# sourceURL=webpack://LSPlugin/./src/LSPlugin.user.ts?");

/***/ }),

/***/ "./src/helpers.ts":
/*!************************!*\
  !*** ./src/helpers.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"path\": () => (/* binding */ path),\n/* harmony export */   \"IS_DEV\": () => (/* binding */ IS_DEV),\n/* harmony export */   \"PROTOCOL_FILE\": () => (/* binding */ PROTOCOL_FILE),\n/* harmony export */   \"PROTOCOL_LSP\": () => (/* binding */ PROTOCOL_LSP),\n/* harmony export */   \"URL_LSP\": () => (/* binding */ URL_LSP),\n/* harmony export */   \"getAppPathRoot\": () => (/* binding */ getAppPathRoot),\n/* harmony export */   \"getSDKPathRoot\": () => (/* binding */ getSDKPathRoot),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"deepMerge\": () => (/* binding */ deepMerge),\n/* harmony export */   \"genID\": () => (/* binding */ genID),\n/* harmony export */   \"ucFirst\": () => (/* binding */ ucFirst),\n/* harmony export */   \"withFileProtocol\": () => (/* binding */ withFileProtocol),\n/* harmony export */   \"safetyPathJoin\": () => (/* binding */ safetyPathJoin),\n/* harmony export */   \"safetyPathNormalize\": () => (/* binding */ safetyPathNormalize),\n/* harmony export */   \"deferred\": () => (/* binding */ deferred),\n/* harmony export */   \"invokeHostExportedApi\": () => (/* binding */ invokeHostExportedApi),\n/* harmony export */   \"setupIframeSandbox\": () => (/* binding */ setupIframeSandbox),\n/* harmony export */   \"setupInjectedStyle\": () => (/* binding */ setupInjectedStyle),\n/* harmony export */   \"setupInjectedUI\": () => (/* binding */ setupInjectedUI),\n/* harmony export */   \"transformableEvent\": () => (/* binding */ transformableEvent),\n/* harmony export */   \"setupInjectedTheme\": () => (/* binding */ setupInjectedTheme)\n/* harmony export */ });\n/* harmony import */ var snake_case__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! snake-case */ \"./node_modules/snake-case/dist.es2015/index.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"./node_modules/path/path.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst path = navigator.platform.toLowerCase() === 'win32' ? path__WEBPACK_IMPORTED_MODULE_0__.win32 : path__WEBPACK_IMPORTED_MODULE_0__.posix;\nconst IS_DEV = \"development\" === 'development';\nconst PROTOCOL_FILE = 'file://';\nconst PROTOCOL_LSP = 'lsp://';\nconst URL_LSP = PROTOCOL_LSP + 'logseq.io/';\nlet _appPathRoot;\nasync function getAppPathRoot() {\n    if (_appPathRoot) {\n        return _appPathRoot;\n    }\n    return (_appPathRoot =\n        await invokeHostExportedApi('_callApplication', 'getAppPath'));\n}\nasync function getSDKPathRoot() {\n    if (IS_DEV) {\n        // TODO: cache in preference file\n        return localStorage.getItem('LSP_DEV_SDK_ROOT') || 'http://localhost:8080';\n    }\n    const appPathRoot = await getAppPathRoot();\n    return safetyPathJoin(appPathRoot, 'js');\n}\nfunction isObject(item) {\n    return (item === Object(item) && !Array.isArray(item));\n}\nfunction deepMerge(target, ...sources) {\n    // return the target if no sources passed\n    if (!sources.length) {\n        return target;\n    }\n    const result = target;\n    if (isObject(result)) {\n        const len = sources.length;\n        for (let i = 0; i < len; i += 1) {\n            const elm = sources[i];\n            if (isObject(elm)) {\n                for (const key in elm) {\n                    if (elm.hasOwnProperty(key)) {\n                        if (isObject(elm[key])) {\n                            if (!result[key] || !isObject(result[key])) {\n                                result[key] = {};\n                            }\n                            deepMerge(result[key], elm[key]);\n                        }\n                        else {\n                            if (Array.isArray(result[key]) && Array.isArray(elm[key])) {\n                                // concatenate the two arrays and remove any duplicate primitive values\n                                result[key] = Array.from(new Set(result[key].concat(elm[key])));\n                            }\n                            else {\n                                result[key] = elm[key];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction genID() {\n    // Math.random should be unique because of its seeding algorithm.\n    // Convert it to base 36 (numbers + letters), and grab the first 9 characters\n    // after the decimal.\n    return '_' + Math.random().toString(36).substr(2, 9);\n}\nfunction ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction withFileProtocol(path) {\n    if (!path)\n        return '';\n    const reg = /^(http|file|lsp)/;\n    if (!reg.test(path)) {\n        path = PROTOCOL_FILE + path;\n    }\n    return path;\n}\nfunction safetyPathJoin(basePath, ...parts) {\n    try {\n        const url = new URL(basePath);\n        if (!url.origin)\n            throw new Error(null);\n        const fullPath = path.join(basePath.substr(url.origin.length), ...parts);\n        return url.origin + fullPath;\n    }\n    catch (e) {\n        return path.join(basePath, ...parts);\n    }\n}\nfunction safetyPathNormalize(basePath) {\n    if (!basePath?.match(/^(http?|lsp|assets):/)) {\n        basePath = path.normalize(basePath);\n    }\n    return basePath;\n}\n/**\n * @param timeout milliseconds\n * @param tag string\n */\nfunction deferred(timeout, tag) {\n    let resolve, reject;\n    let settled = false;\n    const timeFn = (r) => {\n        return (v) => {\n            timeout && clearTimeout(timeout);\n            r(v);\n            settled = true;\n        };\n    };\n    const promise = new Promise((resolve1, reject1) => {\n        resolve = timeFn(resolve1);\n        reject = timeFn(reject1);\n        if (timeout) {\n            // @ts-ignore\n            timeout = setTimeout(() => reject(new Error(`[deferred timeout] ${tag}`)), timeout);\n        }\n    });\n    return {\n        created: Date.now(),\n        setTag: (t) => tag = t,\n        resolve, reject, promise,\n        get settled() {\n            return settled;\n        }\n    };\n}\nfunction invokeHostExportedApi(method, ...args) {\n    method = method?.startsWith('_call') ? method :\n        method?.replace(/^[_$]+/, '');\n    const method1 = (0,snake_case__WEBPACK_IMPORTED_MODULE_2__.snakeCase)(method);\n    // @ts-ignore\n    const logseqHostExportedApi = window.logseq?.api || {};\n    const fn = logseqHostExportedApi[method1] || window.apis[method1] ||\n        logseqHostExportedApi[method] || window.apis[method];\n    if (!fn) {\n        throw new Error(`Not existed method #${method}`);\n    }\n    return typeof fn !== 'function' ? fn : fn.apply(null, args);\n}\nfunction setupIframeSandbox(props, target) {\n    const iframe = document.createElement('iframe');\n    iframe.classList.add('lsp-iframe-sandbox');\n    Object.entries(props).forEach(([k, v]) => {\n        iframe.setAttribute(k, v);\n    });\n    target.appendChild(iframe);\n    return async () => {\n        target.removeChild(iframe);\n    };\n}\nfunction setupInjectedStyle(style, attrs) {\n    const key = attrs['data-injected-style'];\n    let el = key && document.querySelector(`[data-injected-style=${key}]`);\n    if (el) {\n        el.textContent = style;\n        return;\n    }\n    el = document.createElement('style');\n    el.textContent = style;\n    attrs && Object.entries(attrs).forEach(([k, v]) => {\n        el.setAttribute(k, v);\n    });\n    document.head.append(el);\n    return () => {\n        document.head.removeChild(el);\n    };\n}\nconst injectedUIEffects = new Map();\nfunction setupInjectedUI(ui, attrs, initialCallback) {\n    let slot = '';\n    let selector;\n    let float;\n    const pl = this;\n    if ('slot' in ui) {\n        slot = ui.slot;\n        selector = `#${slot}`;\n    }\n    else if ('path' in ui) {\n        selector = ui.path;\n    }\n    else {\n        float = true;\n    }\n    const id = `${ui.key}-${slot}-${pl.id}`;\n    const key = `${ui.key}--${pl.id}`;\n    const target = float ? document.body : (selector && document.querySelector(selector));\n    if (!target) {\n        console.error(`${this.debugTag} can not resolve selector target ${selector}`);\n        return;\n    }\n    if (ui.template) {\n        // safe template\n        ui.template = dompurify__WEBPACK_IMPORTED_MODULE_1___default().sanitize(ui.template, {\n            ADD_TAGS: ['iframe'],\n            ALLOW_UNKNOWN_PROTOCOLS: true,\n            ADD_ATTR: ['allow', 'src', 'allowfullscreen', 'frameborder', 'scrolling', 'target']\n        });\n    }\n    else { // remove ui\n        injectedUIEffects.get(id)?.call(null);\n        return;\n    }\n    let el = document.querySelector(`#${id}`);\n    let content = float ? el?.querySelector('.ls-ui-float-content') : el;\n    if (content) {\n        content.innerHTML = ui.template;\n        // update attributes\n        attrs && Object.entries(attrs).forEach(([k, v]) => {\n            el.setAttribute(k, v);\n        });\n        let positionDirty = el.dataset.dx != null;\n        ui.style && Object.entries(ui.style).forEach(([k, v]) => {\n            if (positionDirty && [\n                'left', 'top', 'bottom', 'right', 'width', 'height'\n            ].includes(k)) {\n                return;\n            }\n            el.style[k] = v;\n        });\n        return;\n    }\n    el = document.createElement('div');\n    el.id = id;\n    el.dataset.injectedUi = key || '';\n    if (float) {\n        content = document.createElement('div');\n        content.classList.add('ls-ui-float-content');\n        el.appendChild(content);\n    }\n    else {\n        content = el;\n    }\n    // TODO: enhance template\n    content.innerHTML = ui.template;\n    attrs && Object.entries(attrs).forEach(([k, v]) => {\n        el.setAttribute(k, v);\n    });\n    ui.style && Object.entries(ui.style).forEach(([k, v]) => {\n        el.style[k] = v;\n    });\n    let teardownUI;\n    let disposeFloat;\n    if (float) {\n        el.setAttribute('draggable', 'true');\n        el.setAttribute('resizable', 'true');\n        ui.close && (el.dataset.close = ui.close);\n        el.classList.add('lsp-ui-float-container', 'visible');\n        disposeFloat = (pl._setupResizableContainer(el, key),\n            pl._setupDraggableContainer(el, { key, close: () => teardownUI(), title: attrs?.title }));\n    }\n    if (!!slot && ui.reset) {\n        const exists = Array.from(target.querySelectorAll('[data-injected-ui]'))\n            .map((it) => it.id);\n        exists?.forEach((exist) => {\n            injectedUIEffects.get(exist)?.call(null);\n        });\n    }\n    target.appendChild(el);\n    // TODO: How handle events\n    ['click', 'focus', 'focusin', 'focusout', 'blur', 'dblclick',\n        'keyup', 'keypress', 'keydown', 'change', 'input'].forEach((type) => {\n        el.addEventListener(type, (e) => {\n            const target = e.target;\n            const trigger = target.closest(`[data-on-${type}]`);\n            if (!trigger)\n                return;\n            const msgType = trigger.dataset[`on${ucFirst(type)}`];\n            msgType && pl.caller?.callUserModel(msgType, transformableEvent(trigger, e));\n        }, false);\n    });\n    // callback\n    initialCallback?.({ el, float });\n    teardownUI = () => {\n        disposeFloat?.();\n        injectedUIEffects.delete(id);\n        target.removeChild(el);\n    };\n    injectedUIEffects.set(id, teardownUI);\n    return teardownUI;\n}\nfunction transformableEvent(target, e) {\n    const obj = {};\n    if (target) {\n        const ds = target.dataset;\n        const FLAG_RECT = 'rect';\n        ['value', 'id', 'className',\n            'dataset', FLAG_RECT\n        ].forEach((k) => {\n            let v;\n            switch (k) {\n                case FLAG_RECT:\n                    if (!ds.hasOwnProperty(FLAG_RECT))\n                        return;\n                    v = target.getBoundingClientRect().toJSON();\n                    break;\n                default:\n                    v = target[k];\n            }\n            if (typeof v === 'object') {\n                v = { ...v };\n            }\n            obj[k] = v;\n        });\n    }\n    return obj;\n}\nlet injectedThemeEffect = null;\nfunction setupInjectedTheme(url) {\n    injectedThemeEffect?.call();\n    if (!url)\n        return;\n    const link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = url;\n    document.head.appendChild(link);\n    return (injectedThemeEffect = () => {\n        try {\n            document.head.removeChild(link);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        injectedThemeEffect = null;\n    });\n}\n\n\n//# sourceURL=webpack://LSPlugin/./src/helpers.ts?");

/***/ }),

/***/ "./src/modules/LSPlugin.Storage.ts":
/*!*****************************************!*\
  !*** ./src/modules/LSPlugin.Storage.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LSPluginFileStorage\": () => (/* binding */ LSPluginFileStorage)\n/* harmony export */ });\n/**\n * A storage based on local files under specific context\n */\nclass LSPluginFileStorage {\n    ctx;\n    /**\n     * @param ctx\n     */\n    constructor(ctx) {\n        this.ctx = ctx;\n    }\n    /**\n     * plugin id\n     */\n    get ctxId() {\n        return this.ctx.baseInfo.id;\n    }\n    /**\n     * @param key A string as file name that support nested directory\n     * @param value Storage value\n     */\n    setItem(key, value) {\n        return this.ctx.caller.callAsync(`api:call`, {\n            method: 'write-plugin-storage-file',\n            args: [this.ctxId, key, value]\n        });\n    }\n    /**\n     * @param key\n     */\n    getItem(key) {\n        return this.ctx.caller.callAsync(`api:call`, {\n            method: 'read-plugin-storage-file',\n            args: [this.ctxId, key]\n        });\n    }\n    /**\n     * @param key\n     */\n    removeItem(key) {\n        return this.ctx.caller.call(`api:call`, {\n            method: 'unlink-plugin-storage-file',\n            args: [this.ctxId, key]\n        });\n    }\n    /**\n     * Clears the storage\n     */\n    clear() {\n        return this.ctx.caller.call(`api:call`, {\n            method: 'clear-plugin-storage-files',\n            args: [this.ctxId]\n        });\n    }\n    /**\n     * @param key\n     */\n    hasItem(key) {\n        return this.ctx.caller.callAsync(`api:call`, {\n            method: 'exist-plugin-storage-file',\n            args: [this.ctxId, key]\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack://LSPlugin/./src/modules/LSPlugin.Storage.ts?");

/***/ }),

/***/ "./src/postmate/index.ts":
/*!*******************************!*\
  !*** ./src/postmate/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"messageType\": () => (/* binding */ messageType),\n/* harmony export */   \"maxHandshakeRequests\": () => (/* binding */ maxHandshakeRequests),\n/* harmony export */   \"generateNewMessageId\": () => (/* binding */ generateNewMessageId),\n/* harmony export */   \"log\": () => (/* binding */ log),\n/* harmony export */   \"resolveOrigin\": () => (/* binding */ resolveOrigin),\n/* harmony export */   \"sanitize\": () => (/* binding */ sanitize),\n/* harmony export */   \"resolveValue\": () => (/* binding */ resolveValue),\n/* harmony export */   \"ParentAPI\": () => (/* binding */ ParentAPI),\n/* harmony export */   \"ChildAPI\": () => (/* binding */ ChildAPI),\n/* harmony export */   \"Postmate\": () => (/* binding */ Postmate),\n/* harmony export */   \"Model\": () => (/* binding */ Model)\n/* harmony export */ });\n// Fork from https://github.com/dollarshaveclub/postmate\n/**\n * The type of messages our frames our sending\n * @type {String}\n */\nconst messageType = 'application/x-postmate-v1+json';\n/**\n * The maximum number of attempts to send a handshake request to the parent\n * @type {Number}\n */\nconst maxHandshakeRequests = 5;\n/**\n * A unique message ID that is used to ensure responses are sent to the correct requests\n * @type {Number}\n */\nlet _messageId = 0;\n/**\n * Increments and returns a message ID\n * @return {Number} A unique ID for a message\n */\nconst generateNewMessageId = () => ++_messageId;\n/**\n * Postmate logging function that enables/disables via config\n */\nconst log = (...args) => Postmate.debug ? console.log(...args) : null;\n/**\n * Takes a URL and returns the origin\n * @param  {String} url The full URL being requested\n * @return {String}     The URLs origin\n */\nconst resolveOrigin = (url) => {\n    const a = document.createElement('a');\n    a.href = url;\n    const protocol = a.protocol.length > 4 ? a.protocol : window.location.protocol;\n    const host = a.host.length ? ((a.port === '80' || a.port === '443') ? a.hostname : a.host) : window.location.host;\n    return a.origin || `${protocol}//${host}`;\n};\nconst messageTypes = {\n    handshake: 1,\n    'handshake-reply': 1,\n    call: 1,\n    emit: 1,\n    reply: 1,\n    request: 1,\n};\n/**\n * Ensures that a message is safe to interpret\n * @param  {Object} message The postmate message being sent\n * @param  {String|Boolean} allowedOrigin The whitelisted origin or false to skip origin check\n * @return {Boolean}\n */\nconst sanitize = (message, allowedOrigin) => {\n    if (typeof allowedOrigin === 'string' &&\n        message.origin !== allowedOrigin)\n        return false;\n    if (!message.data)\n        return false;\n    if (typeof message.data === 'object' &&\n        !('postmate' in message.data))\n        return false;\n    if (message.data.type !== messageType)\n        return false;\n    if (!messageTypes[message.data.postmate])\n        return false;\n    return true;\n};\n/**\n * Takes a model, and searches for a value by the property\n * @param  {Object} model     The dictionary to search against\n * @param  {String} property  A path within a dictionary (i.e. 'window.location.href')\n *                            passed to functions in the child model\n * @return {Promise}\n */\nconst resolveValue = (model, property) => {\n    const unwrappedContext = typeof model[property] === 'function'\n        ? model[property]() : model[property];\n    return Promise.resolve(unwrappedContext);\n};\n/**\n * Composes an API to be used by the parent\n * @param {Object} info Information on the consumer\n */\nclass ParentAPI {\n    parent;\n    frame;\n    child;\n    events = {};\n    childOrigin;\n    listener;\n    constructor(info) {\n        this.parent = info.parent;\n        this.frame = info.frame;\n        this.child = info.child;\n        this.childOrigin = info.childOrigin;\n        if (true) {\n            log('Parent: Registering API');\n            log('Parent: Awaiting messages...');\n        }\n        this.listener = (e) => {\n            if (!sanitize(e, this.childOrigin))\n                return false;\n            /**\n             * the assignments below ensures that e, data, and value are all defined\n             */\n            const { data, name } = (((e || {}).data || {}).value || {});\n            if (e.data.postmate === 'emit') {\n                if (true) {\n                    log(`Parent: Received event emission: ${name}`);\n                }\n                if (name in this.events) {\n                    this.events[name].forEach(callback => {\n                        callback.call(this, data);\n                    });\n                }\n            }\n        };\n        this.parent.addEventListener('message', this.listener, false);\n        if (true) {\n            log('Parent: Awaiting event emissions from Child');\n        }\n    }\n    get(property) {\n        return new Promise((resolve) => {\n            // Extract data from response and kill listeners\n            const uid = generateNewMessageId();\n            const transact = (e) => {\n                if (e.data.uid === uid && e.data.postmate === 'reply') {\n                    this.parent.removeEventListener('message', transact, false);\n                    resolve(e.data.value);\n                }\n            };\n            // Prepare for response from Child...\n            this.parent.addEventListener('message', transact, false);\n            // Then ask child for information\n            this.child.postMessage({\n                postmate: 'request',\n                type: messageType,\n                property,\n                uid,\n            }, this.childOrigin);\n        });\n    }\n    call(property, data) {\n        // Send information to the child\n        this.child.postMessage({\n            postmate: 'call',\n            type: messageType,\n            property,\n            data,\n        }, this.childOrigin);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(callback);\n    }\n    destroy() {\n        if (true) {\n            log('Parent: Destroying Postmate instance');\n        }\n        window.removeEventListener('message', this.listener, false);\n        this.frame.parentNode.removeChild(this.frame);\n    }\n}\n/**\n * Composes an API to be used by the child\n * @param {Object} info Information on the consumer\n */\nclass ChildAPI {\n    model;\n    parent;\n    parentOrigin;\n    child;\n    constructor(info) {\n        this.model = info.model;\n        this.parent = info.parent;\n        this.parentOrigin = info.parentOrigin;\n        this.child = info.child;\n        if (true) {\n            log('Child: Registering API');\n            log('Child: Awaiting messages...');\n        }\n        this.child.addEventListener('message', (e) => {\n            if (!sanitize(e, this.parentOrigin))\n                return;\n            if (true) {\n                log('Child: Received request', e.data);\n            }\n            const { property, uid, data } = e.data;\n            if (e.data.postmate === 'call') {\n                if (property in this.model && typeof this.model[property] === 'function') {\n                    this.model[property](data);\n                }\n                return;\n            }\n            // Reply to Parent\n            resolveValue(this.model, property)\n                .then(value => {\n                e.source.postMessage({\n                    property,\n                    postmate: 'reply',\n                    type: messageType,\n                    uid,\n                    value,\n                }, e.origin);\n            });\n        });\n    }\n    emit(name, data) {\n        if (true) {\n            log(`Child: Emitting Event \"${name}\"`, data);\n        }\n        this.parent.postMessage({\n            postmate: 'emit',\n            type: messageType,\n            value: {\n                name,\n                data,\n            },\n        }, this.parentOrigin);\n    }\n}\n/**\n * The entry point of the Parent.\n */\nclass Postmate {\n    static debug = false; // eslint-disable-line no-undef\n    container;\n    parent;\n    frame;\n    child;\n    childOrigin;\n    url;\n    model;\n    static Model;\n    /**\n     * @param opts\n     */\n    constructor(opts) {\n        this.container = opts.container;\n        this.url = opts.url;\n        this.parent = window;\n        this.frame = document.createElement('iframe');\n        if (opts.id)\n            this.frame.id = opts.id;\n        if (opts.name)\n            this.frame.name = opts.name;\n        this.frame.classList.add.apply(this.frame.classList, opts.classListArray || []);\n        this.container.appendChild(this.frame);\n        this.child = this.frame.contentWindow;\n        this.model = opts.model || {};\n    }\n    /**\n     * Begins the handshake strategy\n     * @param  {String} url The URL to send a handshake request to\n     * @return {Promise}     Promise that resolves when the handshake is complete\n     */\n    sendHandshake(url) {\n        url = url || this.url;\n        const childOrigin = resolveOrigin(url);\n        let attempt = 0;\n        let responseInterval;\n        return new Promise((resolve, reject) => {\n            const reply = (e) => {\n                if (!sanitize(e, childOrigin))\n                    return false;\n                if (e.data.postmate === 'handshake-reply') {\n                    clearInterval(responseInterval);\n                    if (true) {\n                        log('Parent: Received handshake reply from Child');\n                    }\n                    this.parent.removeEventListener('message', reply, false);\n                    this.childOrigin = e.origin;\n                    if (true) {\n                        log('Parent: Saving Child origin', this.childOrigin);\n                    }\n                    return resolve(new ParentAPI(this));\n                }\n                // Might need to remove since parent might be receiving different messages\n                // from different hosts\n                if (true) {\n                    log('Parent: Invalid handshake reply');\n                }\n                return reject('Failed handshake');\n            };\n            this.parent.addEventListener('message', reply, false);\n            const doSend = () => {\n                attempt++;\n                if (true) {\n                    log(`Parent: Sending handshake attempt ${attempt}`, { childOrigin });\n                }\n                this.child.postMessage({\n                    postmate: 'handshake',\n                    type: messageType,\n                    model: this.model,\n                }, childOrigin);\n                if (attempt === maxHandshakeRequests) {\n                    clearInterval(responseInterval);\n                }\n            };\n            const loaded = () => {\n                doSend();\n                responseInterval = setInterval(doSend, 500);\n            };\n            this.frame.addEventListener('load', loaded);\n            if (true) {\n                log('Parent: Loading frame', { url });\n            }\n            this.frame.src = url;\n        });\n    }\n}\n/**\n * The entry point of the Child\n */\nclass Model {\n    child;\n    model;\n    parent;\n    parentOrigin;\n    /**\n     * Initializes the child, model, parent, and responds to the Parents handshake\n     * @param {Object} model Hash of values, functions, or promises\n     * @return {Promise}       The Promise that resolves when the handshake has been received\n     */\n    constructor(model) {\n        this.child = window;\n        this.model = model;\n        this.parent = this.child.parent;\n    }\n    /**\n     * Responds to a handshake initiated by the Parent\n     * @return {Promise} Resolves an object that exposes an API for the Child\n     */\n    sendHandshakeReply() {\n        return new Promise((resolve, reject) => {\n            const shake = (e) => {\n                if (!e.data.postmate) {\n                    return;\n                }\n                if (e.data.postmate === 'handshake') {\n                    if (true) {\n                        log('Child: Received handshake from Parent');\n                    }\n                    this.child.removeEventListener('message', shake, false);\n                    if (true) {\n                        log('Child: Sending handshake reply to Parent');\n                    }\n                    e.source.postMessage({\n                        postmate: 'handshake-reply',\n                        type: messageType,\n                    }, e.origin);\n                    this.parentOrigin = e.origin;\n                    // Extend model with the one provided by the parent\n                    const defaults = e.data.model;\n                    if (defaults) {\n                        Object.keys(defaults).forEach(key => {\n                            this.model[key] = defaults[key];\n                        });\n                        if (true) {\n                            log('Child: Inherited and extended model from Parent');\n                        }\n                    }\n                    if (true) {\n                        log('Child: Saving Parent origin', this.parentOrigin);\n                    }\n                    return resolve(new ChildAPI(this));\n                }\n                return reject('Handshake Reply Failed');\n            };\n            this.child.addEventListener('message', shake, false);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://LSPlugin/./src/postmate/index.ts?");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__values\": () => (/* binding */ __values),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/tslib/tslib.es6.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://LSPlugin/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(__webpack_require__.g.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n//# sourceURL=webpack://LSPlugin/./node_modules/util/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/LSPlugin.core.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});